# コメント許可判定フロー

## 背景

AIがコードを編集する際、コード全体を俯瞰せず部分的な編集を行うため、コメントとコードの整合性が崩れやすい。コードの変更ミスはコンパイルエラーやテストで検知できるが、コメントの陳腐化は機械的に検知できない。そのため、コメントは必要最低限に留める必要がある。

## 原則

1. **コードで表現できることはコードで表現する** - 命名、型、構造で意図を示す
2. **履歴はGitに任せる** - 変更の経緯はコミットログとPRで追跡する
3. **タスク情報はタスク管理ツールに任せる** - Issue、PR、プロジェクト管理ツールを使う
4. **設計判断は設計ドキュメントに書く** - `docs/`配下のドキュメントを活用する
5. **コメントは最後の手段** - 他のすべての手段を検討した上で、どうしても必要な場合のみ

---

## 判定ステップ詳細

### ステップ1: 型・関数の直前のドキュメントコメントか

型定義や関数定義の直前に配置されたドキュメントコメント（JSDoc、TSDoc等）かどうかを判定する。

- **該当する場合** → ステップ3へ（API仕様説明の判定）
- **該当しない場合** → ステップ2へ

---

### ステップ2: ファイルトップの概要コメントか

ファイルの先頭に配置された、そのファイル全体の概要を説明するコメントかどうかを判定する。

#### 許可される内容

- ファイルが**何をまとめた処理群か**の概要説明
- モジュールの責務や役割の概要

```typescript
// 許可例: ファイルの概要
/**
 * ドラッグ&ドロップ操作に関するユーティリティ関数群
 */

// 許可例: モジュールの責務
/**
 * タブの永続化と復元を担当するサービス
 */
```

#### 禁止される内容

- **個別の関数への参照**: 「getXxx関数とsetXxx関数を提供」など
- **個別の実装詳細**: 内部で使用しているデータ構造など
- **冗長な重複**: 関数名やクラス名で既に表現されている内容の繰り返し

```typescript
// 禁止例: 個別関数への言及
/**
 * タブ管理モジュール
 * - createTab(): 新しいタブを作成
 * - closeTab(): タブを閉じる
 * - getActiveTab(): アクティブなタブを取得
 */

// 禁止例: 冗長な説明
/**
 * TabManager
 * タブを管理するためのマネージャークラス  ← クラス名から明らか
 */
```

- **概要として適切な場合** → 【許可】
- **個別の実装・関数への参照がある場合** → 【禁止】
- **ファイルトップの概要でない場合** → ステップ4へ

---

### ステップ3: 外部利用者向けのAPI仕様説明か

関数や型を外部から利用する際に必要な情報のみを記載しているかを判定する。

#### 許可される内容

- 関数が**何をするか**の説明（動作の概要）
- 引数に**何を渡すべきか**の説明
- 戻り値が**何を表すか**の説明
- 発生しうる例外やエラーの説明
- 使用上の注意点（スレッドセーフ性、冪等性など）

```typescript
// 許可例
/**
 * 指定されたユーザーIDに紐づくタブ一覧を取得する。
 * @param userId - 対象ユーザーのID
 * @returns タブの配列。ユーザーが存在しない場合は空配列
 */
function getTabsByUserId(userId: string): Tab[] { ... }
```

#### 禁止される内容

- **変更履歴**: 過去の実装からの変更点
- **内部実装の詳細**: 外部から使う上で知る必要のない情報
- **TODO/FIXME**: タスク管理ツールで管理すべき情報

```typescript
// 禁止例: 変更履歴
/**
 * タブ一覧を取得する。
 * v2.0でキャッシュ機構を追加した。  ← 禁止（変更履歴）
 * 内部ではMapを使って高速化している。 ← 禁止（内部実装詳細）
 */
function getTabs(): Tab[] { ... }
```

- **該当する場合** → 【許可】
- **該当しない場合** → 【禁止】

---

### ステップ4: 過去の実装への言及があるか

コメントが過去の状態・以前の実装・変更の経緯に言及しているかを判定する。

#### 禁止されるパターン

| パターン | 理由 |
|----------|------|
| 「〇〇しないように変更」 | 以前の実装はGit履歴で確認できる |
| 「〇〇の実装を追加」 | 何を追加したかはGit履歴で確認できる |
| 「以前は〇〇だったが…」 | 過去の状態はGit履歴で確認できる |
| 「テストを通すために〇〇」 | テストが通ることはCI/テスト実行で確認できる |
| 「〇〇のバグを修正」 | 修正内容はGit履歴とIssueで確認できる |

```typescript
// 禁止例
// 以前はfilterを使っていたがパフォーマンス問題でforループに変更
for (const tab of tabs) { ... }

// 禁止例
// Issue #123 で報告されたバグを修正するためにnullチェックを追加
if (value !== null) { ... }
```

- **過去への言及がある場合** → 【禁止】
- **過去への言及がない場合** → ステップ5へ

---

### ステップ5: 価値判断・設計判断を含むか

複数の選択肢からの選択理由、トレードオフの説明、設計上の決定根拠などを含むかを判定する。

- **価値判断を含む場合** → ステップ6へ
- **価値判断を含まない場合** → ステップ7へ

---

### ステップ6: その価値判断をコードに残す必要があるか

価値判断の重要度とスコープに基づいて、コメントとして残すべきかを判定する。

#### 禁止されるパターン

| パターン | 理由 |
|----------|------|
| 「〇〇を実装する」 | 実装されていることはコードを見ればわかる |
| 「〇〇ではなく✗✗を使う」 | 使っているものはコードを見ればわかる |
| 「〇〇の方が良いので採用」（軽微な決定） | 軽微な設計決定は残す価値がない |
| 全体設計に関わる重大な決定 | 設計ドキュメント（`docs/`等）に記載すべき |

```typescript
// 禁止例: コードを見ればわかる
// Mapを使う
const cache = new Map<string, Tab>();

// 禁止例: 軽微な決定
// forEachよりfor...ofの方が読みやすいので採用
for (const item of items) { ... }

// 禁止例: 設計ドキュメントに書くべき
// 状態管理にReduxではなくZustandを採用。
// 理由: バンドルサイズの削減とボイラープレートの軽減
```

#### 許可されるパターン

以下の**すべて**を満たす場合のみ許可：

1. 設計上の重要な決定である
2. スコープがクラス・関数内に閉じている（外部設計書に書くには局所的すぎる）
3. この情報がないと将来の開発者が誤った変更をする可能性が高い

```typescript
// 許可例: 局所的だが重要な設計判断
// WeakMapを使用している理由:
// - Tabオブジェクトがガベージコレクトされた際にキャッシュも自動解放される
// - Mapを使うとメモリリークの原因となる
// この挙動に依存しているため、Mapへの変更は禁止
private tabCache = new WeakMap<Tab, CachedData>();
```

- **残す必要がある（上記条件をすべて満たす）** → 【許可】（慎重に判断）
- **残す必要がない** → 【禁止】

---

### ステップ7: タスク実行時のメモ的情報か

現在実行中のタスクや作業プロセスに関する情報かどうかを判定する。

#### 禁止されるパターン

| パターン | 理由 |
|----------|------|
| 「ユーザーの指示により〇〇」 | タスクの実行方法はコードと無関係 |
| 「テストを通すために〇〇」 | 最終的にテストが通ることが重要でありその過程は不要 |
| 「デバッグ用に追加」 | デバッグ完了後は不要な情報 |
| 「レビュー指摘により修正」 | レビュー履歴はPR/MRで確認できる |
| 「一時的な対応」 | 一時的であることを示すならIssueで管理すべき |

```typescript
// 禁止例
// ユーザーからの要望でこの機能を追加
function exportToCsv() { ... }

// 禁止例
// このテストが落ちていたのでnullチェックを追加
if (data !== null) { ... }

// 禁止例
// PR #456 のレビューで指摘されたので修正
const sanitized = sanitizeInput(input);
```

- **タスク実行のメモである場合** → 【禁止】
- **タスク実行のメモでない場合** → ステップ8へ

---

### ステップ8: 変数名・関数名で表現できるか

コメントの内容が適切な命名で代替可能かを判定する。

#### 禁止されるパターン

```typescript
// 禁止例: 変数名で表現可能
// ユーザー情報を取得
const data = fetchData();
// → 改善: const userData = fetchUserData();

// 禁止例: 関数名で表現可能
// タブを閉じる
closeItem();
// → 改善: closeTab();

// 禁止例: 変数名で表現可能
// アクティブなタブのみ
const tabs = allTabs.filter(t => t.active);
// → 改善: const activeTabs = allTabs.filter(t => t.active);

// 禁止例: 変数名がすでに表現している内容の繰り返し
// モックのストレージサービスを作成
mockStorageService = { get: vi.fn(), set: vi.fn() };
// → 変数名mockStorageServiceで「モックのストレージサービス」であることは自明

// 禁止例: 変数の用途が名前で明らか
// タイムアウト設定
const timeout = 5000;
// → timeoutという名前で自明
```

コメントを書く代わりに、命名を改善することを検討する。**変数名がすでにコメントの内容を表現している場合、そのコメントは冗長である。**

- **命名で表現できる場合** → 【禁止】（命名を改善せよ）
- **命名で表現できない場合** → ステップ9へ

---

### ステップ9: 型で表現できるか

コメントの内容が型システムで表現可能かを判定する。

#### 禁止されるパターン

```typescript
// 禁止例: 型で表現可能
// ユーザーIDは文字列
const userId = "123";
// → 改善: const userId: UserId = "123";

// 禁止例: 型で表現可能
// nullにはならない
const user = getUser()!;
// → 改善: 関数の戻り値型を修正するか、型ガードを使用
```

- **型で表現できる場合** → 【禁止】（型定義を改善せよ）
- **型で表現できない場合** → ステップ10へ

---

### ステップ10: ライブラリの一般的なプラクティスの説明か

使用しているライブラリ（React、Vue、Express等）の一般的な使い方やパターンを説明するコメントかどうかを判定する。

#### 禁止されるパターン

ライブラリを習熟した開発者であれば知っているべき一般的なパターンは、コメントで説明する必要がない。

```typescript
// 禁止例: Reactの一般的なパターン
// refでドラッグ状態を追跡（イベントハンドラ内で最新値を参照するため）
const dragStateRef = useRef<DragState>(initialDragState);

// 禁止例: Reactのクロージャ問題への対応
// コールバックをrefで保持（イベントハンドラ内で最新値を参照するため）
const callbacksRef = useRef({ onDragStart, onDragMove });

// 禁止例: useCallbackの依存配列安定化
// getSubtreeNodeIdsをrefで保持（useCallbackの依存配列を安定化）
const getSubtreeNodeIdsRef = useRef(getSubtreeNodeIds);

// 禁止例: Reactのレンダリングフェーズ
// レンダリング中にrefを参照しないよう状態として保持
const [rect, setRect] = useState<DOMRect | null>(null);
```

これらはReact開発者にとって一般的な知識であり、コメントがなくてもコードを読めば理解できる。

#### 許可されるパターン

プロジェクト固有の使い方や、一般的ではない特殊な理由がある場合は許可される。

```typescript
// 許可例: プロジェクト固有の理由
// refを使用する理由: このプロジェクトではパフォーマンス計測のため
// すべての状態更新を追跡しており、useStateだとノイズが発生する
const valueRef = useRef(initialValue);
```

- **一般的なライブラリプラクティスの説明である場合** → 【禁止】
- **一般的なプラクティスでない場合** → ステップ11へ

---

### ステップ11: 数値型の単位・マジックナンバー・難読な値を説明するコメントか

数値リテラルや数値型フィールドの単位（ミリ秒、秒、分、ピクセル等）、マジックナンバー、または難読な値（カラーコード等）を説明するコメントかどうかを判定する。

#### 許可されるパターン

単位を型で表現する必要がないほど軽微な場合、コメントで単位を明記することは許可される。

```typescript
// 許可例: 時間の単位
private readonly DEBOUNCE_MS = 300; // ミリ秒
const timeout = 5000; // ms
const interval = 60; // 秒

// 許可例: サイズの単位
const margin = 8; // px
const threshold = 0.5; // ratio (0-1)
```

マジックナンバーや、コードを見ただけでは意味が分からない難読な値に対するコメントは許可される。

```typescript
// 許可例: カラーコードの色名
const PRESET_COLORS = [
  '#ef4444', // Red
  '#f97316', // Orange
  '#3b82f6', // Blue
];

// 許可例: HTTPステータスコード
if (response.status === 429) { // Too Many Requests
  await delay(retryAfter);
}

// 許可例: ビットフラグ
const flags = 0x04; // READ_ONLY
```

#### 禁止されるパターン

変数名に単位を含められる場合はコメントより命名を優先する。

```typescript
// 禁止例: 変数名で表現可能
const timeout = 5000; // ミリ秒
// → 改善: const timeoutMs = 5000;

// ただし、定数やフィールドで既に名前に単位が含まれている場合は
// 追加のコメントは不要
private readonly DEBOUNCE_MS = 300; // ← コメント不要、名前で明らか
```

- **単位・マジックナンバー・難読な値の説明であり、命名で表現困難な場合** → 【許可】
- **命名で表現可能な場合** → 【禁止】
- **該当しない場合** → ステップ12へ

---

### ステップ12: インターフェースフィールドの型情報補足コメントか

インターフェースやtype定義のフィールドに対して、string型が実際には特定の形式（JSON、URL、日付文字列等）であることを補足するコメントかどうかを判定する。

#### 許可されるパターン

型システムでは表現しきれない、フィールドの実際のデータ形式を説明するコメントは許可される。

```typescript
// 許可例: JSONシリアライズされたデータ
interface SnapshotRecord {
  id: string;
  data: string; // JSON stringified SnapshotData
}

// 許可例: 特定形式の文字列
interface Config {
  dateStr: string; // ISO 8601 format
  apiEndpoint: string; // Must end with /api/v1
}

// 許可例: Chrome APIの用語補足
interface ExtendedTabInfo {
  discarded: boolean; // 休止状態のタブ（まだ読み込まれていない）
}
```

#### 禁止されるパターン

```typescript
// 禁止例: 型名で自明
interface User {
  name: string; // ユーザー名 ← stringであることは自明
}
```

- **型で表現困難なデータ形式の説明の場合** → 【許可】
- **型名で自明な場合** → 【禁止】
- **該当しない場合** → ステップ13へ

---

### ステップ13: テストコード特有のコメントか

テストファイル（`*.test.ts`, `*.test.tsx`, `*.spec.ts`）内のコメントかどうかを判定する。

#### 許可されるパターン

##### Arrange/Act/Assertパターン

テストのフェーズを明示するAAA（Arrange/Act/Assert）コメントは許可される。

```typescript
// 許可例: AAAパターン
test('should update user profile', async () => {
  // Arrange
  const user = createTestUser();
  const newData = { name: 'New Name' };

  // Act
  await updateProfile(user.id, newData);

  // Assert
  expect(await getUser(user.id)).toMatchObject(newData);
});
```

##### テストの事前条件・期待状態を図示するASCIIアート

テストで構築するデータ構造（ツリー、グラフ等）を視覚的に示すASCIIアートは、テストシナリオの理解を大幅に助ける場合に許可される。

```typescript
// 許可例: テストで構築するツリー構造
test('should move tab with subtree', async () => {
  // 初期状態:
  // parent
  //   ├── child1
  //   │   └── grandchild
  //   └── child2
  const parent = await createTab();
  const child1 = await createTab({ parentId: parent.id });
  // ...
});
```

ただし、**すべてのテストに闇雲に追加するのではなく**、図示することでコードを読む際の認知負荷が大幅に下がる場合のみ使用する。

##### テストシナリオの自然言語説明

テスト名だけでは表現しきれない、テストの目的・前提条件・期待結果を明確にするための自然言語説明は許可される。

```typescript
// 許可例: 複雑なシナリオの説明
test('handles race condition in concurrent updates', () => {
  // このテストは、同じリソースに対して複数の更新が同時に発生した場合に、
  // 最後の更新のみが反映され、中間状態が保存されないことを検証する。
  // 実際の環境では発生頻度は低いが、発生時のデータ整合性を保証するために必要。
});
```

#### 禁止されるパターン

```typescript
// 禁止例: テスト名と重複
describe('UserService', () => {
  // UserServiceのテスト ← describe名と重複
});

// 禁止例: コードを見ればわかる内容
// モックのストレージサービスを作成
mockStorageService = { get: vi.fn(), set: vi.fn() };
// → 変数名mockStorageServiceで自明

// 禁止例: 意図が不明確な待機（意図の説明があれば許可）
// 非同期処理が完了するまで待機
await new Promise(resolve => setTimeout(resolve, 10));
// → 何を待っているのかの意図が不明確
```

- **AAA・ASCIIアート・シナリオ説明として適切な場合** → 【許可】
- **テスト名と重複、またはコードで自明な場合** → 【禁止】
- **テストコードでない場合、または該当しない場合** → ステップ14へ

---

### ステップ14: 複雑な処理の事前条件・事後条件の整理か

複雑な処理の結果として成立している条件を説明するコメントかを判定する。

#### 検討すべきこと

コメントを書く前に以下を検討する：

1. 処理を関数に抽出して名前を付けられないか
2. 処理の順序を変更して見通しを良くできないか
3. 中間変数を導入して意図を明確にできないか
4. アサーションで条件を表現できないか

```typescript
// 改善前（コメントに頼っている）
// 複雑な計算...
let x = /* 複雑な処理 */;
// ここでxは必ず正の数になる
processPositiveNumber(x);

// 改善後（コードで表現）
const x = calculatePositiveValue(/* 入力 */);
console.assert(x > 0, 'x must be positive');
processPositiveNumber(x);
```

#### 許可されるパターン

どのような改善を試みても複雑さが避けられず、条件が自明でない場合のみ許可。

```typescript
// 許可例: アルゴリズムの不変条件
// ループ不変条件: この時点で left <= pivot < right が成立
// この条件が崩れるとパーティションが正しく動作しない
while (left < right) {
  // クイックソートのパーティション処理
  ...
}
```

- **コードで表現できる場合** → 【禁止】（コードを改善せよ）
- **どうしても表現できない場合** → 【許可】
- **事前条件の整理ではない場合** → ステップ15へ

---

### ステップ15: 処理順序の制約を説明するコメントか

処理の実行順序が重要であり、順序を入れ替えると不具合が発生することを説明するコメントかどうかを判定する。

#### 許可されるパターン

以下の**すべて**を満たす場合のみ許可：

1. 処理の順序を入れ替えても一見動作しそうに見える
2. しかし実際には順序が重要で、入れ替えると不具合が発生する
3. その制約がコード構造からは明らかでない

```typescript
// 許可例: 順序が重要だが見た目上は入れ替え可能に見える
// 複製前にService Workerに複製元を登録（onCreatedより先に実行される必要がある）
await chrome.runtime.sendMessage({
  type: 'REGISTER_DUPLICATE_SOURCE',
  payload: { sourceTabId: tabId },
});
await chrome.tabs.duplicate(tabId);

// 許可例: 初期化順序の制約
// loadState()はsyncWithChromeTabs()より先に実行する必要がある
// （保存済みの親子関係を先に復元しないと同期時に失われる）
await manager.loadState();
await manager.syncWithChromeTabs();
```

#### 禁止されるパターン

順序を入れ替えるおそれがない場合はコメント不要。

```typescript
// 禁止例: 戻り値の依存関係から順序が明らか
const user = await fetchUser(id);
const profile = await fetchProfile(user.profileId); // userがないと動かない

// 禁止例: 変数スコープから順序が明らか
const result = calculate(input);
console.log(result); // resultがないとエラー
```

- **入れ替え可能に見えるが順序が重要な場合** → 【許可】
- **順序が自明な場合** → 【禁止】
- **順序制約の説明でない場合** → ステップ16へ

---

### ステップ16: 多段階処理の各段階を説明するコメントか

コードを見ただけでは把握しにくい多段階の処理において、各段階を説明するコメントかどうかを判定する。

#### 許可されるパターン

以下の**すべて**を満たす場合のみ許可：

1. 処理が複数の段階に分かれている
2. 関数に分離するほどではない（分離すると逆に可読性が下がる）
3. コメントが**各処理の直前**に配置されている

```typescript
// 許可例: 2段階処理の説明（各処理の直前に配置）
// ストレージに保存されたchildren配列の順序を維持して再構築
// 2段階で処理: 1. 保存された順序で追加、2. parentIdで関連付けられているが未追加の子を追加
const addedChildIds = new Set<string>();

// 第1段階: 保存された順序で子を追加
for (const childId of savedChildren) {
  ...
}

// 第2段階: parentIdで関連付けられているが、まだ追加されていない子を追加（フォールバック）
Object.entries(reconstructedNodes).forEach(([id, node]) => {
  ...
});
```

#### 禁止されるパターン

```typescript
// 禁止例: 処理から離れた位置にコメント
/**
 * この関数は3段階で処理を行う:
 * 1. データを取得
 * 2. データを変換
 * 3. データを保存
 */
function processData() {
  // ここには何もコメントがない
  const data = fetch();
  // ここにも何もない
  const transformed = transform(data);
  // ここにも...
  save(transformed);
}
// → 改善: 各処理の直前にコメントを置くか、コメントなしでも理解できるように関数分離

// 禁止例: 関数に分離すべき複雑さ
// 段階1: ユーザー認証
// ... 50行の認証処理 ...
// 段階2: データ取得
// ... 50行のデータ取得 ...
// → 改善: authenticateUser(), fetchData() に分離
```

- **多段階処理で、各処理の直前にコメントがある場合** → 【許可】
- **処理から離れた位置にある場合** → 【禁止】
- **関数に分離すべき複雑さの場合** → 【禁止】（関数に分離せよ）
- **多段階処理の説明でない場合** → ステップ17へ

---

### ステップ17: ハック・ワークアラウンド・意図的なエラー握りつぶしか

通常とは異なる使い方、ライブラリのバグ回避、意図的な規約違反、意図的なエラー無視などかを判定する。

#### 許可されるパターン

以下のようなハック的コードには、その理由を説明するコメントが許可される：

```typescript
// 許可例: 副作用の意図的利用
// getComputedStyleを呼び出すことでスタイルの再計算を強制する
// (DOMの変更を即座に反映させるため)
void getComputedStyle(element).opacity;

// 許可例: ライブラリのバグ回避
// React 18.2のuseEffectのクリーンアップでrefがnullになるバグの回避
// https://github.com/facebook/react/issues/xxxxx
const ref = useRef<HTMLElement | null>(null);
const stableRef = useRef(ref.current);

// 許可例: ブラウザ互換性のためのハック
// Safari では scrollIntoView の behavior: 'smooth' が
// 特定条件下で動作しないため、polyfillを使用
import smoothscroll from 'smoothscroll-polyfill';

// 許可例: 意図的なエラー握りつぶし
} catch (_error) {
  // タブが存在しない場合のエラーは無視（正常な動作）
}

// 許可例: サイレント失敗
} catch (_error) {
  // ストレージ保存失敗は無視（次回再試行される）
}

// 許可例: エラーを無視する理由の説明
} catch (_error) {
  // クリーンアップ失敗は致命的ではないため無視
}
```

**エラーを握りつぶすcatchブロック**では、なぜエラーを無視しても問題ないかを説明するコメントが許可される。これにより将来の開発者が「エラーハンドリングが不足している」と誤解することを防ぐ。

#### 検討すべきこと

ハックを書く前に以下を検討する：

1. ハックなしで目的を達成できないか
2. ライブラリのアップデートで解決しないか
3. 別のライブラリで代替できないか

- **避けられないハック・意図的なエラー無視である場合** → 【許可】
- **ハック・エラー無視でない場合** → ステップ18へ

---

### ステップ18: 通常の想定と異なる「びっくり度」の高い動作か

関数名や変数名から通常期待される動作と異なる、意外性のある実装を説明するコメントかどうかを判定する。

#### 許可されるパターン

名前から想定される動作と実際の動作が異なり、その差異が重要な場合は許可される。

```typescript
// 許可例: 更新なのに一部を無視する意外な動作
// タイトル、ファビコン、URL、ピン状態、discarded状態のいずれかが変更された場合のみ更新
// Note: status単体の変更では新規エントリを作成しない（余分なLoadingタブ防止）
function handleTabUpdated(tabId: number, changeInfo: TabChangeInfo) {
  if (!changeInfo.title && !changeInfo.favIconUrl && ...) {
    return; // statusのみの変更は無視
  }
  ...
}

// 許可例: 選択解除しない意外な動作
// Note: アクティブタブ変更時に選択状態を解除しない
// ツリー内でのタブクリックでもonActivatedが発火するため、
// クリック時の選択操作と競合してしまう
function handleTabActivated(tabId: number) {
  // 選択解除しない
  ...
}
```

#### 禁止されるパターン

びっくり度が低い場合や、命名・関数分離で対応可能な場合は禁止。

```typescript
// 禁止例: 命名で対応可能
// 新しいタブは末尾に追加
tabs.push(newTab);
// → 改善: appendTabToEnd(newTab);

// 禁止例: びっくり度が低い
// nullの場合はデフォルト値を使用
const value = input ?? defaultValue;
// → 自明なので不要
```

- **名前から想定される動作と異なり、重要な場合** → 【許可】
- **びっくり度が低い、または命名で対応可能** → 【禁止】
- **該当しない場合** → ステップ19へ

---

### ステップ19: コードだけでは意図が不明確な処理か

コードを読めば「何をしているか」は分かるが、「なぜそれをしているのか」の意図が不明確な処理を説明するコメントかどうかを判定する。

#### 許可されるパターン

コードの動作は明確だが、その目的・理由が分からない場合は意図を説明するコメントが許可される。

```typescript
// 許可例: 待機の理由が不明確
// Reactの状態更新がDOMに反映されるのを待つ
await new Promise(resolve => setTimeout(resolve, 10));

// 許可例: なぜ特定の値なのかが不明確
// Chrome拡張機能のAPIレート制限を回避するため
const BATCH_SIZE = 50;

// 許可例: なぜこの順序なのかが不明確
// IndexedDBのトランザクションが完了する前にconnectionを閉じるとエラーになるため
await transaction.done;
db.close();
```

#### 禁止されるパターン

コードを読めば意図も明確に分かる場合はコメント不要。

```typescript
// 禁止例: 意図が自明
// ユーザーが存在しない場合はnullを返す
if (!user) return null;
// → nullガードは一般的なパターンで意図は自明

// 禁止例: 命名で意図が表現可能
// キャッシュをクリアする
data = null;
// → 改善: clearCache() のような関数に抽出

// 禁止例: 動作の説明であり意図ではない
// 10ミリ秒待機する
await new Promise(resolve => setTimeout(resolve, 10));
// → 「待機する」はコードで分かる。「なぜ待機するか」が意図
```

- **コードだけでは意図が不明確で、意図を説明している場合** → 【許可】
- **意図が自明、または動作の説明にすぎない場合** → 【禁止】
- **該当しない場合** → ステップ20へ

---

### ステップ20: 未分類（要報告）

ここまでのステップで判定できないコメントは、このフローの改善が必要であることを示している。

コメントを残してタスクを完了したのち、
タスク完了後に以下の情報をユーザーに報告し、フローの改善に役立てる：

- コメントの全文
- コメントが書かれているファイルと行番号
- コメントの意図（推測）
- なぜ既存のステップで判定できなかったか

---

## 判定結果サマリー

| ステップ | 条件 | 結果 |
|----------|------|------|
| 2 | ファイルトップの概要（冗長でない） | 許可 |
| 2 | 個別関数への参照・冗長な説明 | 禁止 |
| 3 | 外部利用者向けAPI仕様説明 | 許可 |
| 3 | 変更履歴・内部実装詳細 | 禁止 |
| 4 | 過去の実装への言及 | 禁止 |
| 6 | 局所的かつ重要な設計判断 | 許可（慎重に） |
| 6 | 軽微な決定・全体設計 | 禁止 |
| 7 | タスク実行のメモ | 禁止 |
| 8 | 命名で表現可能 | 禁止 |
| 9 | 型で表現可能 | 禁止 |
| 10 | ライブラリの一般的プラクティス | 禁止 |
| 11 | 数値型の単位・マジックナンバー・難読な値（命名困難） | 許可 |
| 11 | 命名で表現可能 | 禁止 |
| 12 | 型で表現困難なデータ形式の説明 | 許可 |
| 12 | 型名で自明 | 禁止 |
| 13 | テスト：AAA・ASCIIアート・シナリオ説明 | 許可 |
| 13 | テスト：テスト名と重複・コードで自明 | 禁止 |
| 14 | 不可避な事前条件説明 | 許可 |
| 14 | コードで表現可能 | 禁止 |
| 15 | 入れ替え可能に見える順序制約 | 許可 |
| 15 | 順序が自明な場合 | 禁止 |
| 16 | 多段階処理（各処理の直前） | 許可 |
| 16 | 処理から離れた位置・関数分離すべき | 禁止 |
| 17 | 不可避なハック・バグ回避 | 許可 |
| 17 | 意図的なエラー握りつぶし | 許可 |
| 18 | びっくり度の高い意外な動作 | 許可 |
| 18 | びっくり度が低い・命名で対応可能 | 禁止 |
| 19 | 意図が不明確なコードの意図説明 | 許可 |
| 19 | 意図が自明・動作の説明にすぎない | 禁止 |
| 20 | 未分類 | 要報告 |
