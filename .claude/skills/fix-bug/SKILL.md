---
name: fix-bug
description: バグ修正作業を開始する前に読み込むべき行動規範
---

# バグ修正時の行動規範

このドキュメントは、バグ修正作業を行う際に必ず遵守すべき規範を定めたものである。
バグ修正を開始する前に、必ずこのドキュメントを読み込み、以下の規範に従って作業を行うこと。

## 1. 根本原因の特定を最優先する

### 禁止事項
- **場当たり的な修正の禁止**: 表面的な症状を解消するだけの修正を行ってはならない
- **推測に基づく修正の禁止**: 「おそらくこれが原因だろう」という推測だけで修正を行ってはならない
- **時間ベースの待機追加の禁止**: `setTimeout`、`sleep`、固定時間待機などを「安定させるため」という理由で追加してはならない

### 必須事項
- バグの再現条件を明確に特定する
- データフローを追跡し、どこで期待値と実際の値が乖離するかを特定する
- ログやデバッガを使用して、実際の実行パスと値を確認する
- 「なぜそうなるのか」を説明できるまで調査を続ける

## 2. フォールバックによる問題の隠蔽を禁止する

### 禁止事項
- **事前条件の不正をフォールバックで吸収することの禁止**: 事前条件が満たされていない場合、フォールバック値を返してテストを通すことは禁止
- **nullチェックの安易な追加禁止**: 「nullの場合は何もしない」というコードを、なぜnullになるかを調査せずに追加してはならない
- **try-catchによる例外の握りつぶし禁止**: 例外が発生する根本原因を調査せずに、catchで握りつぶしてはならない

### 必須事項
- 事前条件が満たされない場合は、**なぜ満たされないのか**を調査する
- フォールバックを追加する場合は、それが**設計上正当な理由**があることを説明できなければならない
- 予期しない状態の場合は、エラーを投げるか、明確なログを出力して問題を可視化する

## 3. 仮説の検証を徹底する

### 禁止事項
- **「テストが通った = 原因が正しかった」という短絡的結論の禁止**: テストが通っても、その修正が本当の原因を解決したとは限らない
- **副作用による解決の見落とし禁止**: 修正が意図しない副作用で問題を解決している可能性を常に考慮する
- **仮説を立てたらすぐに修正に着手することの禁止**: 仮説を立てたら、まずその仮説が正しいかを検証する方法を考える

### 必須事項

#### 仮説検証のプロセス
1. **仮説を明文化する**: 「〜が原因で〜が起きている」という形で仮説を明確に記述する
2. **仮説を検証する方法を考える**: 修正前に、その仮説が正しいことを確認するための検証方法を考える
3. **最小限の修正で検証する**: 仮説を検証するために、最小限の変更で効果を確認する
4. **修正後も仮説を疑う**: 修正後、以下の質問に答えられなければならない：
   - この修正がなぜ問題を解決するのか、論理的に説明できるか？
   - 他の原因が同時に解決されている可能性はないか？
   - この修正を元に戻したら、確実に問題が再発するか？

#### 検証の具体的手法
- 修正前後でログを比較し、期待通りのデータフローになっているか確認する
- 修正を一部だけ適用して、どの部分が効果的かを切り分ける
- 問題の再現テストを複数回実行し、統計的に有意な結果を得る

## 3.5 推測と検証の精度に関する必須要件（最重要）

試行錯誤ループ自体は禁止しないが、**推測の精度が十分でない状態での検証は禁止する**。

### 禁止されるパターン

1. **表面的な挙動だけからの推測**
   - ❌「タイムアウトしてるからイベント発火が遅いのかも」
   - ✅ コードパスを追跡し「この行でこの値がこうなるからタイムアウトする」と特定

2. **「気になったから試す」**
   - ❌ コードを見て気になる箇所があったから変更して実行
   - ✅ コードパスを完全に理解し「ここでバグが起きるはず」という確信を得てから検証

3. **テスト結果の統計で判断**
   - 「10回中1回→2回になったので悪化」は統計的に無意味
   - 「失敗率が改善した」は根本解決の証明にならない
   - 判断基準：**失敗が1回でもあれば未解決。0回でも原因不明なら未解決**

### 推測前の必須調査プロセス

1. **観察**: ログ追加・デバッガ等で、問題発生時に**実際に何が起きているか**を記録する
2. **追跡**: 問題が発生するコードパスを**完全に**追跡し、各ステップで変数・状態がどう変化するかを理解する
3. **特定**: 「この行で、この条件で、この値になるから問題が起きる」と言えるまで調査する
4. **説明**: **「なぜそうなるか」を論理的に説明できる状態**になってから、初めて修正を検討する

### 検証の正しい手順

1. 原因を特定し、**なぜその原因で問題が起きるか**を説明できる
2. 修正内容が**なぜその原因を解決するか**を説明できる
3. その状態で初めて修正コードを書き、テストで確認する
4. テストが通っても、上記の説明ができなければ**未解決として扱う**

## 4. デバッグ用コードの管理を徹底する

### 禁止事項
- **デバッグ用コードの放置禁止**: 調査のために追加した関数、ログ出力、一時的な変数を放置してはならない
- **「後で消す」の禁止**: デバッグ用コードを「後で消す」つもりで残してはならない。調査が終わったら即座に削除する
- **検証用関数の本番コード混入禁止**: 検証のために一時的に追加した関数を、本番のロジックで使用してはならない

### 必須事項

#### デバッグコードの追跡
- デバッグ用コードを追加する際は、`[DEBUG]`プレフィックスや専用のコメントで明示的にマークする
- デバッグコードを追加したファイルと行番号を記録しておく
- 調査が完了したら、追加したデバッグコードを**全て**削除する

#### 検証用コードの扱い
- 検証用に追加した関数は、検証が終わったら即座に削除する
- 検証用関数が有用だと判断した場合は、正式な設計レビューを経て本番コードに組み込む
- 一時的な修正が効果的だった場合でも、それが正しい解決策かを再評価する

## 5. 修正方法の複数案検討を必須とする

### 禁止事項
- **原因特定後の即座のコーディング禁止**: 原因が分かった後に、修正方法を深く検討せずにすぐにコードを書き始めてはならない
- **最初に思いついた方法での修正禁止**: 最初に思いついた修正方法が最善とは限らない。必ず複数の選択肢を検討する
- **修正方法の比較検討なしの実装禁止**: 複数案のPros/Consを比較せずに修正を開始してはならない

### 必須事項

#### 修正方法検討のプロセス
1. **複数の修正案を列挙する**: 最低2つ以上の修正方法を考える
2. **各案のPros/Consを明確にする**: それぞれの修正方法の長所と短所を書き出す
3. **「あるべき姿」を基準に評価する**: 修正後のコードが設計として正しい状態になるかを評価する
4. **最善の方法を選択する**: Pros/Consを踏まえて、最も適切な修正方法を選択する

#### 検討すべき観点
- この修正は根本的な解決か、それとも対症療法か？
- 修正後のコードは、バグがなかったとしたら書いたであろうコードになっているか？
- 将来の拡張性や保守性に問題はないか？
- 同様のバグが他の箇所で発生する可能性はないか？その場合、より広範な修正が必要ではないか？

## 6. 修正範囲の大きさを恐れない

### 禁止事項
- **修正範囲を理由にした妥協の禁止**: 「影響範囲が大きくなるから」という理由で、中途半端な修正を選択してはならない
- **ユーザー確認なしの回避禁止**: 根本的な修正が必要だと分かっているのに、ユーザーに確認せずに小さな修正で済ませてはならない
- **編集範囲をマイナス要素として評価することの禁止**: 複数案を比較する際、編集範囲の大きさをマイナス要素として考えてはならない

### 必須事項

#### 修正範囲に関する原則
- バグの根本原因を修正し、コードを「あるべき姿」にすることが最優先
- 影響範囲が大きくなることは、正しい修正を行うための必要なコストである
- 全体設計を見直す必要がある場合は、それを避けずに正面から取り組む

#### 大規模な修正が必要な場合のプロセス
1. **修正の必要性を明確にする**: なぜ大規模な修正が必要なのかを説明できるようにする
2. **設計方針をユーザーに確認する**: 根本的な書き換えが必要な場合は、その設計方針についてユーザーの承認を得る
3. **段階的に実装する**: 大規模な修正を適切な単位に分割して実装する
4. **各段階でテストを実行する**: 修正の各段階でテストが通ることを確認する

#### 禁止される判断パターン
- 「この修正は大きすぎるから、とりあえずこの範囲だけ直そう」
- 「全部直すと時間がかかるから、最小限の修正にしよう」
- 「他の部分に影響が出るから、ここだけ特別な処理を入れよう」

## 7. バグ修正の完了条件

バグ修正が完了したと言えるのは、以下の全ての条件を満たした場合のみである：

### 7.1 絶対的な完了条件

1. **根本原因の確定的な特定**: バグの根本原因を**推測ではなく確定的に**特定し、説明できる
   - 「〜の可能性がある」「〜かもしれない」という表現での原因説明は認めない
   - 「〜が原因である。なぜなら〜」という確定的な説明ができなければならない
   - デバッグログ、コード追跡、または再現テストにより原因を**実証**していること

2. **修正と原因の直接的な対応**: 修正内容が根本原因を**直接**解決している
   - 修正が原因に対して「直接的」であり、「間接的」や「副次的」な効果に依存していないこと
   - 修正コードのどの部分が、原因のどの部分を解決するのか、1対1で説明できること

3. **再発防止の証明**: 同じコードパスで同じ問題が**二度と起きない**ことを証明できる
   - 修正後、問題の発生条件を意図的に作り出しても問題が起きないことを確認
   - 単に「テストが通った」だけでは証明にならない

### 7.2 禁止される完了宣言パターン

以下のパターンでの完了宣言は**絶対に禁止**：

- 「修正したらテストが通るようになった」→ たまたま通っただけの可能性を排除できていない
- 「〜の可能性があったので修正した」→ 可能性ではなく確定的な原因特定が必要
- 「問題が再現しなくなった」→ 再現しなくなった理由を説明できなければならない
- 「複数回テストを実行して全部成功した」→ 統計的成功は根本解決の証明にならない

### 7.3 標準的な完了条件

4. **複数案の検討**: 複数の修正方法を検討し、Pros/Consを比較した上で最善の方法を選択した
5. **修正の妥当性**: その修正がなぜ問題を解決するのか、論理的に説明できる
6. **あるべき姿の実現**: 修正後のコードが「バグがなかったとしたら書いたであろうコード」になっている
7. **全テストのオールグリーン**: 修正後、**全てのテストが成功**していること
   - 修正対象のバグに関連するテストだけでなく、**プロジェクト全体のテストがパスしていること**が必要
   - 修正と関係なく失敗しているテストがある場合でも、それを放置してはならない
   - 全テストがオールグリーンの状態を維持することがバグ修正完了の必須条件である
8. **副作用の確認**: 修正が他の機能に悪影響を与えていないことを確認する
9. **デバッグコードの除去**: 調査のために追加したコードが全て削除されている
10. **コードの清潔さ**: 不要なフォールバック、一時的な修正、コメントアウトされたコードが残っていない

### 7.4 完了報告の必須要素

バグ修正の完了を報告する際は、以下の要素を**必ず**含めること：

1. **根本原因の説明**: 確定的な原因の説明（推測ではない）
2. **原因の実証方法**: どのようにしてその原因を特定したか（ログ、トレース等）
3. **修正内容と原因の対応関係**: 修正のどの部分が原因のどの部分を解決するか
4. **再発防止の証明方法**: 同じ問題が起きないことをどのように確認したか

## 8. バグ修正時のチェックリスト

バグ修正作業を行う前に、以下のチェックリストを確認すること：

### 調査フェーズ
- [ ] バグの再現手順を明確にしたか？
- [ ] ログやデバッガを使用して実際の動作を確認したか？
- [ ] データフローを追跡して、どこで問題が発生しているか特定したか？
- [ ] 「なぜそうなるのか」を説明できるか？

### 仮説フェーズ
- [ ] 仮説を明文化したか？
- [ ] 仮説を検証する方法を考えたか？
- [ ] 場当たり的な修正ではなく、根本原因に対する修正か？

### 修正方法検討フェーズ
- [ ] 複数の修正案（最低2つ以上）を列挙したか？
- [ ] 各案のPros/Consを明確にしたか？
- [ ] 修正後のコードが「あるべき姿」になるかを評価したか？
- [ ] 編集範囲の大きさをマイナス要素として考えずに評価したか？
- [ ] 同様のバグが他の箇所で発生する可能性を検討したか？

### 修正フェーズ
- [ ] 根本原因に対する修正か（対症療法ではないか）？
- [ ] フォールバックで問題を隠蔽していないか？
- [ ] 固定時間待機を追加していないか？
- [ ] 修正範囲が大きくなることを理由に妥協していないか？
- [ ] 大規模な修正が必要な場合、ユーザーに設計方針を確認したか？

### 検証フェーズ
- [ ] 修正がなぜ問題を解決するのか論理的に説明できるか？
- [ ] 修正を元に戻したら問題が再発することを確認したか？
- [ ] 他の副作用で解決されている可能性を排除したか？
- [ ] 統計的に有意な回数のテストを実行したか？

### フレーキーテストの確認方法
**重要**: Playwrightの`--repeat-each`オプションは使用しないこと。`--repeat-each`を使用すると、Service Workerのライフサイクル管理の問題でフレーキーが発生する可能性がある。

**確認回数の決定基準**:
- フレーキーが見つかっていない通常確認: 10回
- 1回でも失敗が発生した後の確認: 50回以上（フレーキーが完全に解消されたと言えるまで）

### 完了フェーズ
- [ ] デバッグ用コードを全て削除したか？
- [ ] 不要なフォールバックや一時的なコードが残っていないか？
- [ ] コードがクリーンな状態か？
- [ ] 修正後のコードは「バグがなかったとしたら書いたであろうコード」になっているか？

---

**このドキュメントに記載された規範に従わないバグ修正は、たとえテストが通っても完了とは認められない。**
